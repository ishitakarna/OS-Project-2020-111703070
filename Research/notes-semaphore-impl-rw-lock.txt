Semaphore: int initialized to some value
two operations
Wait(sem *s) {
	while(s <=0)
		block(); // could be ";"
	s--;
}
signal(sem *s) {
	s++;
}
Both the wait and signal should be atomic. 
This is the sematics of the semaphore. The meaning. 
-----------
How to implement a semaphore? 
We can use the tool called spinlock that we already have.

struct semaphore {
	int val;
	spinlock lk;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
wait(semaphore *s) {
	spinlock(&(s->sl));
	while(s->val <=0)
	;
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	spinunlock(*(s->sl));
}
--> problem? 
- suppose 2 processes trying wait. 
val = 1;
Th1: spinlock
Th2: spinlock-waits
Th1: while -> false, val = 0; spinulock; 
Th2: spinlock success; while() -> true, loops;
Th1: is done with critical section, it calls signal. it calls spinlock() -> wait. 

Who is holding spinlock-> Th2. Itis waiting for val > 0.  Who can set value > 0 , ans: Th1, and Th1 is waiting for spinlock which is held by The2. 
What do we have hear? -> circular wait. Deadlock.
None of them will proceed. 

Solution2: 
struct semaphore {
	int val;
	spinlock lk;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
wait(semaphore *s) {
	spinlock(&(s->sl));
	while(s->val <=0) {
		spinunlock(&(s->sl));
		spinlock(&(s->sl));
	}
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	spinunlock(*(s->sl));
}

Problem: race in spinlock of whille loop and signal's spinlock. Bounded wait not guaranteed
=------
Further: spinlocks are not good for a long wait.

Solution3: 
struct semaphore {
	int val;
	spinlock lk;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
block() {
	put this current process on wait-q;
	schedule();
}
wait(semaphore *s) {
	spinlock(&(s->sl));
	while(s->val <=0) {
		Block(); 
	}
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	spinunlock(*(s->sl));
}

Solution 3: Further updated
Solution3: 
struct semaphore {
	int val;
	spinlock lk;
	list l;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
block(semaphore *s) {
	listappend(s->l, current);
	schedule();
}
wait(semaphore *s) {
	spinlock(&(s->sl));
	while(s->val <=0) {
		block(s); 
	}
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	spinunlock(*(s->sl));
}

-> violates the rule - don't block holding a spinlock.

Solution 3 - v3
struct semaphore {
	int val;
	spinlock lk;
	list l;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
block(semaphore *s) {
	listappend(s->l, current);
	schedule();
}
wait(semaphore *s) {
	spinlock(&(s->sl));
	while(s->val <=0) {
		spinunlock(&(s->sl));
		block(s); 
	}
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	spinunlock(*(s->sl));
}

-> problem is that block() will be called without holding the spinlock and the access to the list is not protected. 
Note that - so far we have ignored changes to signal()

Solution 3 - v4
struct semaphore {
	int val;
	spinlock lk;
	list l;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
block(semaphore *s) {
	listappend(s->l, current);
	spinunlock(&(s->sl));
	schedule();
}
wait(semaphore *s) {
	spinlock(&(s->sl));
	while(s->val <=0) {
		block(s); 
	}
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	x = dequeue(s->sl) and enqueue(readyq, x);
	spinunlock(*(s->sl));
}

Problem: after a blocked process comes out of the block, it does not hold the spinlock and it's goinng to change the s->sl;

Solution 3 - v5
struct semaphore {
	int val;
	spinlock lk;
	list l;
};
sem_init(semaphore *s, int initval) {
	s->val = initval;
	s->sl = 0;
}
block(semaphore *s) {
	listappend(s->l, current);
	spinunlock(&(s->sl));
	schedule();
}
wait(semaphore *s) {
	spinlock(&(s->sl)); // A
	while(s->val <=0) {
		block(s);  
		spinlock(&(s->sl)); // B
	}
	(s->val)--;
	spinunlock(&(s->sl));
}
signal(seamphore *s) {
	spinlock(*(s->sl));
	(s->val)++;
	x = dequeue(s->sl) and enqueue(readyq, x);
	spinunlock(*(s->sl));
}
Question: there is race between A and B. Can we guarantee bounded wait ? 



----------

read write lock - let's define an ADT

typedef .... rwlock;

lockShared(rwlock *l);
lockExlc(rwlock *l);
unlockShared(rwlock *l);
unlockExlc(rwlock *l);

let's try to do a typedef for rwlock.

typedef struct rwlock {
	//Need to know if anyone is holding the lock ? 
	int active;
	//Need to know if lock is held for r or w
	int type;
	// need to know how many readers are active (so that we can wait for all of them to get over 
	int readers;
	// need to know how many readers and writers are waiting;
	int nreadwait, nwritewait;
	// queues needed to keep processes waiting. 2 - 1 for readers, 1 for writers.
	queue readq, writeq;
	// need to protect the variables above. let's say one spinlock for all
	spinlock lk;
}

Q: Can we replace some of these with a semaphore. 
Hw: write rwlock code. 
